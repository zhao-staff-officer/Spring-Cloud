# Zookeeper

[TOC]



## 1.0 分布式理论

### ACID

- 原子性（Atomicity）

  事务必须是一个原子的操作序列单元，事务中包含的各项操作在一次执行过程中，全部执行成功或者全部不执行。任何一项操作都将导致整个事务失败，同时其他已经执行的操作都将被撤销并回滚，只有所有操作全部成功，整个事务才算是成功执行。

- 一致性（Consistency）

  事务的一致性是指事务执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处于一致性状态。也就是说，事务执行的结果必须是使数据库从一个一致性状态转变到另一个一致性状态，因此当数据库只包含成功事务提交的结果时，就能说数据库处于一致性状态。而如果数据库系统在运行过程中发生故障，有些事务尚未完成就被迫中断，这些未完成的事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说不一致的状态。

- 隔离性（Isolation）

  在并发环境中，并发的事务是相互隔离的，一个事务的执行不能被其他事务干扰。也就是说，不同事务并发操作相同的数据时，每个事务都有各自完整的数据空间，即一个事务内部的操作及使用的数据对其他并发事务是隔离的，并发执行各个事务不能互相干扰

  1. 读未提交（ReadUncommitted）

     如果一个事务正在处理某一数据，并对其进行了更新，但同时尚未完成事务，因此还没有进行事务提交；而与此同时，允许另个事务也能够访问改数据。

  2. 读已提交（ReadCommited）

     只允许获取已经提交的数据。

  3. 可重复度（RepetableRead）

     事务在处理过程稿，多次读取同一数据时，其值都和事务开始时刻是一致的。因此该事务级别禁止了不可重复读取与脏读，但是有肯呢个出现幻影数据。幻影数据指同样的事务操作，在前后两个时间段内执行对同一数据项的读取，可能出现不一致的结果。

  4. 串行化（Serializable）

     | 隔离级别 | 脏读 | 不可重复读 | 幻读 |
     | :------: | :--: | :--------: | :--: |
     | 读未提交 |  ✓   |     ✓      |  ✓   |
     | 读已提交 |  ×   |     ✓      |  ✓   |
     | 可重复读 |  ×   |     ×      |  ✓   |
     |  串行化  |  ×   |     ×      |  ×   |
     
     
     
     **脏读(Drity Read)：** 
     
     某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的
     
     
     
     **不可重复读(Non-repeatable read):**
     
     在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。
     
     
     
     **幻读(Phantom Read):**
     
     在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。
     
     

- 持久性（Durability）

  事务的持久性也被称为永久性，是指一个事务一旦提交，它对数据库中对应数据的状态变更应该是永久性的。换句话说，一旦某个事务成功结束，那么它对数据库所做的更新就必须永久保存下来-即使反思系统崩溃或者机器宕机等故障，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束时的状态。

### CAP

​		一个分布式系统不可能同时满足一致性（C:Consistency）、可用性（A：Availability）和分区容错性（P：Partition tolerance） 这三个基本需求，最多只能同时满足其中两项。

- 一致性

​		在分布式环境中，一致性是指数据在多个副本之间是否能够保存一致的特效。在一致性的需求下，当一个系统在数据一致的状态下执行更新操作后，应该保证系统的数据任然处于一致的状态。  

1. 强一致性
2. 弱一致性
3. 最终一致性

- 可用性

​		可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作总是能够在有限时间内返回结果。

- 分区容错性

​		分区容错性约束了一个分布式系统需要具有如下特性：分布式系统在遇到任何网络分区故障的时候，任然能够保证堆外提供满足一致性和可用性的服务，除非是整个网络环境发送了故障。



### BASE

​	BASE是BasicallyAvailable(基本可用)，Soft state(软状态) 和Eventually consistent(最终一致性) 三个短语的简写。BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性，担每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。

- 基本可用

​		基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。

- 弱状态

​		弱状态也称为软状态，和硬件状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程中存在延时。

- 最终一致性

​		最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致性的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时系统数据的强一致性。

1. 因果一致性
2. 读己之所写
3. 会话一致性
4. 单调读一致性
5. 单调写一致性

## 2.0 一致性协议 2PC与3PC

​	在分布式系统中，每一个机器节点虽然都能够明确的知道自己在进行事务操作过程中的结果是成功或失败，担无法直接获取到其他分布式节点的操作过程。因此，在一个事务操作需要跨多个分布式节点时候，为了保证事务处理的ACID特效，就需要引入一个称为“协作者（Coordinator）”的组建来统一调度所有分布式节点的执行逻辑，这些被调度的分布式节点则被称为“参与者（Participant）”。协调者负责独爱度参与者的行为，并最终决定这些参与者是否把事务正在进行提交。基于这个思想，衍生出了二阶段提交合三阶段提交两种协议。

### 2PC （Two-Phase Commit）

- 阶段一：提交事务请求（投票阶段）

  1. 事务询问

     协调者向所有参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应。

  2. 执行事务

     各参与者执行事务操作，并将Undeo和Redo信息计入事务日志中

  3. 各参与者向协调者反馈事务询问的响应

     如果参与者执行了事务操作，那么反馈给协调者yes响应，表示事务可以执行；如果参与者没有成功执行事务，那么反馈给协调者No响应，表示事务不可以执行。

- 阶段二：执行事务提交

  1. 执行事务提交
  2. 中断事务

- 优缺点
  1. 有点：原理简单，实现方便
  2. 缺点：同步阻塞，单点问题，脑裂，太过保守

### 3PC （Three-Phase Commit）

- 阶段一：CanCommit

  1. 事务询问

     协调者向所有参与者发送一个包含事务内容的canCommit请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应。

  2. 各参与者向协调者反馈事务询问的响应

     参与者接受到来自协调者的canCommit请求后，正常情况下，如果其自身认为可以顺利执行事务，那么会反馈Yes响应，并进入预备状态，否者反馈NO响应。

- 阶段二：PreCommit

  1. 执行事务预提交
  2. 中断事务

- 阶段三：DoCommit

  1. 执行提交
  2. 中断事务

- 优缺点
  1. 有点：降低了参与者的阻塞范围，并且能够在出现点点故障后继续达成一致
  2. 缺点：三阶段提交协议在参与者收到preCommit消息后，如果网络出现分区，此时协调者所在的节点和参与者无法进行正常的网络通信，在这种情况下，该参与者依赖会进行事务的提交，这必然出现数据的不一致性。

## 3.0 Paxos算法

​		

## 4.0 Zookeeper

​	Zookeeper是一个典型的分布式数据一致性的解决方案，分布式应用程序可以基于它实现诸如数据发布/订阅，负载均衡，命名服务，分布式协调/通知，集群管理，Master选举，分布式锁和分布式队列等功能。Zookeeper可以保证如下分布式一致性特性。

1. 顺序一致

   从同一个客户端发起的事务请求，最终将会严格地按照其发起顺序被应用到Zookeeper中去。

2. 原子性

   所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群所有机器都成功应用某一个事务，要么都没有应用，一定不会出现集群中部分机器应用了该事务，而另外一部分没有应用的情况。

3. 单一视图

   无论客户端连接的是哪个Zookeeper服务器，其看到的服务端数据模型都是一致的。

4. 可靠性

   一旦服务端成功地应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会一直保存下来，除非有另一个事务又对其进行了变更。

5. 实时性

   通常人们看到实时性的第一反应是，一旦一个事务被成功应用，那么客户端能够立即从服务端上读取这个事务变更后的最新数据状态。这里需要注意的事，Zookeeper仅仅保证在一定的时间段内，客户端最终一定能够从服务端上读取到最新的数据状态。
   
### 4.1 集群角色

1. Leader

   Zookeeper集群中所有机器通过一个Leader选举过程来选定一台被称为“Leader”的机器，Leader服务器为客户端提供读和写服务。

2. Follower

3. Observer	

   
   
### 4.2 zookeeper部署

#### 	4.2.1 单机模式

#### 	4.2.2 集群模式

#### 	4.2.3 伪集群模式

### 4.3 API使用

#### 	4.3.1创建会话

```java
Zookeeper zookeeper = new ZooKeeper( String connectString,int sessionTimeout,Watcher watcher, boolean canBeReadOnly, HostProvider aHostProvider, ZKClientConfig clientConfig)
```

```java
Zookeeper zookeeper = new ZooKeeper(String connectString, int sessionTimeout,Watcher watcher,long sessionId, byte[] sessionPasswd, boolean canBeReadOnly,HostProvider aHostProvider,ZKClientConfig clientConfig)
```

   

| 参数                    | 说明                                                         |
| :---------------------- | ------------------------------------------------------------ |
| connectString           | zk链接地址，多个逗号分隔：ep:127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002/app/a |
| sessionTimeout          | 会话超时时间                                                 |
| watcher                 | 通知事件                                                     |
| canBeReadOnly           | 客户端是否只读，如果设置只读则不能写入数据                   |
| sessionId/sessionPasswd | 标识同一客户端，在初次创建客户端后会返回会话ID与会话钥匙，可使用同一客户端。 |

   

#### 	4.3.2 创建节点









